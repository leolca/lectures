<?xml version="1.0" encoding="UTF-8"?>
<quiz>


<question type="category">
<category>
<text>$course$/R-exams/Exercise 1</text>
</category>
</question>


<question type="cloze">
<name>
<text> R1 Q1 : scalarquantization_companding01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Suponha que um sinal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math> será amostrado e quantizado através de um quantizador escalar uniforme. O sinal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math> possui extensão <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math>. Um quantizador qualquer pode ser expresso por uma função <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>:</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo>→</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>y</mi><mi>M</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">Q: \mathbb{R} \rightarrow \{y_1, \ldots, y_M\}</annotation></semantics></math>, onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> representa o número de níveis de quantização e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">y_i</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,M</annotation></semantics></math>, os pontos de representação. Considerando um quantizador uniforme com 2 bits, faça o que se pede:</p>
<ol style="list-style-type: lower-alpha">
<li>Determine os pontos de representação <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">y_i</annotation></semantics></math> e os limiares do quantizador, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>i</mi></msub><annotation encoding="application/x-tex">t_i</annotation></semantics></math>;
<ul>
<li>opção a-A = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0.125, 0.375, 0.625, 0.875]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.25, 0.5, 0.75]</code></li>
<li>opção a-B = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[-0.5, 0, 0.5]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[-0.25, 0, 0.25]</code></li>
<li>opção a-C = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0, 0.25, 0.5, 0.75]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.125, 0.375, 0.625]</code></li>
<li>opção a-D = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0.25, 0.5, 0.75, 1]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.375, 0.625, 0.875]</code></li>
</ul></li>
<li><p>Usualmente, para avaliar a performance de um quantizador, utiliza-se o erro médio quadrático (MSE), e para tanto, utilizamos como medida de distorção o quadrado da diferença, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>Q</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mi>Q</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d(x,Q(x)) = (x - Q(x))^2</annotation></semantics></math>. Calcule o valor esperado da distorção <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">D(Q)</annotation></semantics></math> para um sinal de entrada com distribuição uniforme.</p></li>
<li><p>Calcule a relação sinal-ruído de quantização para um sinal de entrada com distribuição uniforme.</p></li>
<li><p>Calcule a relação sinal-ruído de quantização para um sinal de entrada senoidal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(t) = \frac{1}{2}\left( 1 + \sin(\omega t) \right)</annotation></semantics></math>.</p></li>
</ol>
<ol type = "a">
<li> {1:MULTICHOICE:%100%opção a-A~%0%opção a-B~%0%opção a-C~%0%opção a-D~%0%nenhuma das anteriores} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac></mrow><annotation encoding="application/x-tex">D(Q) = \frac{1}{192}</annotation></semantics></math>. {1:NUMERICAL:=0.0052083:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>12.0412</mn></mrow><annotation encoding="application/x-tex">D(Q) = 12.0412</annotation></semantics></math>dB. {1:NUMERICAL:=12.0412:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>13.76</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 13.76</annotation></semantics></math>dB. {1:NUMERICAL:=13.80211:0.01} </li>
</ol>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<p>Como o quantizador é de 2-bits, teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2^2 = 4</annotation></semantics></math> pontos de representação no intervalo <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math>. Iremos dividir o intervalo <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math> em 4 regiões de mesmo tamanho (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.25</mn><annotation encoding="application/x-tex">0.25</annotation></semantics></math>): <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>0.25</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,0.25)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.25</mn><mo>,</mo><mn>0.5</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0.25,0.5)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.5</mn><mo>,</mo><mn>0.75</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0.5,0.75)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.75</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0.75,1]</annotation></semantics></math>. Os limiares então serão: 0.25, 0.5 e 0.75. Os pontos de representação serão colocados no meio de cada intervalo: 0.125, 0.375, 0.625 e 0.875.</p>
<p>Abaixo seguem os cálculos de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">D(Q)</annotation></semantics></math> para um sinal com distribuição uniforme na entrada. Para facilitar, reconhecemos que cada uma das 4 integrais no somatório possuem o mesmo valor. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msubsup><mo>∫</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mi>i</mi></msub></msubsup><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∫</mo><mn>0</mn><mn>0.25</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.125</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.25</mn><mn>0.5</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.375</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.5</mn><mn>0.75</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.625</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.75</mn><mn>1</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.875</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mo>×</mo><mn>4</mn><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∫</mo><mn>0</mn><mn>0.25</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.125</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mn>1</mn><mn>8</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mi>x</mi><mo>−</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mfrac><msup><mi>x</mi><mn>3</mn></msup><mn>3</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mo minsize="3.0" maxsize="3.0" stretchy="false" form="postfix">|</mo><mn>0</mn><mfrac><mn>1</mn><mn>4</mn></mfrac></msubsup></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
D(Q) &amp;= \sum_i \int_{t_{i-1}}^{t_i} f(x) (x - y_i)^2 \mathrm{d}x \\
     &amp;= \frac{1}{4} \left( \int_{0}^{0.25}(x-0.125)^2 dx + \int_{0.25}^{0.5}(x-0.375)^2 dx + \int_{0.5}^{0.75}(x-0.625)^2 dx + \int_{0.75}^{1}(x-0.875)^2 dx \right) \\
     &amp;= \frac{1}{4} \times 4 \times \left( \int_{0}^{0.25}(x-0.125)^2 dx \\
     &amp;= \left(\left(\frac{1}{8}\right)^2 x - \frac{1}{4} x^2 + \frac{x^3}{3} \right) \Bigg\rvert_0^{\frac{1}{4}} \\
     &amp;= \frac{1}{192} .
\end{aligned}
</annotation></semantics></math></p>
<p>A relação sinal-ruído de quantização pode ser obtida utilizando a expressão: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\sigma_x^2}{\sigma_q^2} \right)
</annotation></semantics></math> onde, para o quantizador uniforme temos <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><msup><mi>Δ</mi><mn>2</mn></msup><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">
\sigma_q^2 = \frac{\Delta^2}{12} 
</annotation></semantics></math> e para o sinal de entrada <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∼</mo><mstyle mathvariant="script"><mi>𝒰</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \sim \mathcal{U}(a,b)</annotation></semantics></math> temos <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">
\sigma_x^2 = \frac{(b-a)^2}{12}
</annotation></semantics></math> e assim para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∼</mo><mstyle mathvariant="script"><mi>𝒰</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \sim \mathcal{U}(0,1)</annotation></semantics></math> teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">\sigma_x^2 = \frac{1}{12}</annotation></semantics></math>. A relação sinal-ruído de quantização, para o quantizador com <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n=2</annotation></semantics></math> bits e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mo>=</mo><mn>1</mn><mi>/</mi><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\Delta = 1/2^n</annotation></semantics></math> = 1/4, será então <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mfrac><mn>1</mn><mn>12</mn></mfrac><mfrac><mrow><mn>1</mn><mi>/</mi><mn>16</mn></mrow><mn>12</mn></mfrac></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mn>16</mn><mo>=</mo><mn>12.0412</mn><mtext mathvariant="normal">dB</mtext><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\frac{1}{12}}{\frac{1/16}{12}} \right) = 10 \log 16 = 12.0412 \text{dB}.
</annotation></semantics></math></p>
<p>Para calcular a SQNR para o sinal senoidal proposto, note que <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><mi>A</mi><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t) = \frac{1}{2} + A \sin(\omega t)</annotation></semantics></math>, onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">A = \frac{1}{2}</annotation></semantics></math>. A constante não muda o resultado e poderemos utilizar a fórmula: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQRN</mtext><mo>=</mo><mn>6</mn><mi>n</mi><mo>+</mo><mn>1.76</mn><mtext mathvariant="normal">dB</mtext><mo>,</mo></mrow><annotation encoding="application/x-tex">
\text{SQRN} = 6n + 1.76 \text{dB} ,
</annotation></semantics></math> onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> é o número de bits do quantizador. Teremos então um <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>13.76</mn><mtext mathvariant="normal">dB</mtext></mrow><annotation encoding="application/x-tex">\text{SQNR} = 13.76 \text{dB}</annotation></semantics></math>. Se calcularmos utilizando <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\Delta = \frac{1}{4}</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">\sigma_x^2 = \frac{1}{8}</annotation></semantics></math>, obteremos o mesmo resultado: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>12</mn><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup></mrow><msup><mi>Δ</mi><mn>2</mn></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mn>24</mn><mtext mathvariant="normal">dB</mtext><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\sigma_x^2}{\sigma_q^2} \right) = 10 \log \left( \frac{12 \sigma_x^2}{\Delta^2} \right) = 10 \log 24 \text{dB}.
</annotation></semantics></math></p>
<ol type = "a">
<li> True. / False. / False. / False. / False </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac><mo>=</mo><mn>0.0052083</mn></mrow><annotation encoding="application/x-tex">D(Q) = \frac{1}{192} = 0.0052083</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mn>16</mn><mo>=</mo><mn>12.0412</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 10 \log 16 = 12.0412</annotation></semantics></math>dB. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mn>24</mn><mo>=</mo><mn>13.80211</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 10 \log 24 = 13.80211</annotation></semantics></math>dB. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>4</defaultgrade>
</question>


<question type="cloze">
<name>
<text> R2 Q1 : scalarquantization_companding01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Suponha que um sinal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math> será amostrado e quantizado através de um quantizador escalar uniforme. O sinal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math> possui extensão <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math>. Um quantizador qualquer pode ser expresso por uma função <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>:</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo>→</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>y</mi><mi>M</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">Q: \mathbb{R} \rightarrow \{y_1, \ldots, y_M\}</annotation></semantics></math>, onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> representa o número de níveis de quantização e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">y_i</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,M</annotation></semantics></math>, os pontos de representação. Considerando um quantizador uniforme com 2 bits, faça o que se pede:</p>
<ol style="list-style-type: lower-alpha">
<li>Determine os pontos de representação <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">y_i</annotation></semantics></math> e os limiares do quantizador, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>i</mi></msub><annotation encoding="application/x-tex">t_i</annotation></semantics></math>;
<ul>
<li>opção a-A = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0.125, 0.375, 0.625, 0.875]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.25, 0.5, 0.75]</code></li>
<li>opção a-B = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[-0.5, 0, 0.5]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[-0.25, 0, 0.25]</code></li>
<li>opção a-C = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0, 0.25, 0.5, 0.75]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.125, 0.375, 0.625]</code></li>
<li>opção a-D = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0.25, 0.5, 0.75, 1]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.375, 0.625, 0.875]</code></li>
</ul></li>
<li><p>Usualmente, para avaliar a performance de um quantizador, utiliza-se o erro médio quadrático (MSE), e para tanto, utilizamos como medida de distorção o quadrado da diferença, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>Q</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mi>Q</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d(x,Q(x)) = (x - Q(x))^2</annotation></semantics></math>. Calcule o valor esperado da distorção <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">D(Q)</annotation></semantics></math> para um sinal de entrada com distribuição uniforme.</p></li>
<li><p>Calcule a relação sinal-ruído de quantização para um sinal de entrada com distribuição uniforme.</p></li>
<li><p>Calcule a relação sinal-ruído de quantização para um sinal de entrada senoidal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(t) = \frac{1}{2}\left( 1 + \sin(\omega t) \right)</annotation></semantics></math>.</p></li>
</ol>
<ol type = "a">
<li> {1:MULTICHOICE:%100%opção a-A~%0%opção a-B~%0%opção a-C~%0%opção a-D~%0%nenhuma das anteriores} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac></mrow><annotation encoding="application/x-tex">D(Q) = \frac{1}{192}</annotation></semantics></math>. {1:NUMERICAL:=0.0052083:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>12.0412</mn></mrow><annotation encoding="application/x-tex">D(Q) = 12.0412</annotation></semantics></math>dB. {1:NUMERICAL:=12.0412:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>13.76</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 13.76</annotation></semantics></math>dB. {1:NUMERICAL:=13.80211:0.01} </li>
</ol>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<p>Como o quantizador é de 2-bits, teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2^2 = 4</annotation></semantics></math> pontos de representação no intervalo <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math>. Iremos dividir o intervalo <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math> em 4 regiões de mesmo tamanho (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.25</mn><annotation encoding="application/x-tex">0.25</annotation></semantics></math>): <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>0.25</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,0.25)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.25</mn><mo>,</mo><mn>0.5</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0.25,0.5)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.5</mn><mo>,</mo><mn>0.75</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0.5,0.75)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.75</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0.75,1]</annotation></semantics></math>. Os limiares então serão: 0.25, 0.5 e 0.75. Os pontos de representação serão colocados no meio de cada intervalo: 0.125, 0.375, 0.625 e 0.875.</p>
<p>Abaixo seguem os cálculos de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">D(Q)</annotation></semantics></math> para um sinal com distribuição uniforme na entrada. Para facilitar, reconhecemos que cada uma das 4 integrais no somatório possuem o mesmo valor. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msubsup><mo>∫</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mi>i</mi></msub></msubsup><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∫</mo><mn>0</mn><mn>0.25</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.125</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.25</mn><mn>0.5</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.375</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.5</mn><mn>0.75</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.625</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.75</mn><mn>1</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.875</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mo>×</mo><mn>4</mn><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∫</mo><mn>0</mn><mn>0.25</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.125</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mn>1</mn><mn>8</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mi>x</mi><mo>−</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mfrac><msup><mi>x</mi><mn>3</mn></msup><mn>3</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mo minsize="3.0" maxsize="3.0" stretchy="false" form="postfix">|</mo><mn>0</mn><mfrac><mn>1</mn><mn>4</mn></mfrac></msubsup></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
D(Q) &amp;= \sum_i \int_{t_{i-1}}^{t_i} f(x) (x - y_i)^2 \mathrm{d}x \\
     &amp;= \frac{1}{4} \left( \int_{0}^{0.25}(x-0.125)^2 dx + \int_{0.25}^{0.5}(x-0.375)^2 dx + \int_{0.5}^{0.75}(x-0.625)^2 dx + \int_{0.75}^{1}(x-0.875)^2 dx \right) \\
     &amp;= \frac{1}{4} \times 4 \times \left( \int_{0}^{0.25}(x-0.125)^2 dx \\
     &amp;= \left(\left(\frac{1}{8}\right)^2 x - \frac{1}{4} x^2 + \frac{x^3}{3} \right) \Bigg\rvert_0^{\frac{1}{4}} \\
     &amp;= \frac{1}{192} .
\end{aligned}
</annotation></semantics></math></p>
<p>A relação sinal-ruído de quantização pode ser obtida utilizando a expressão: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\sigma_x^2}{\sigma_q^2} \right)
</annotation></semantics></math> onde, para o quantizador uniforme temos <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><msup><mi>Δ</mi><mn>2</mn></msup><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">
\sigma_q^2 = \frac{\Delta^2}{12} 
</annotation></semantics></math> e para o sinal de entrada <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∼</mo><mstyle mathvariant="script"><mi>𝒰</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \sim \mathcal{U}(a,b)</annotation></semantics></math> temos <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">
\sigma_x^2 = \frac{(b-a)^2}{12}
</annotation></semantics></math> e assim para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∼</mo><mstyle mathvariant="script"><mi>𝒰</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \sim \mathcal{U}(0,1)</annotation></semantics></math> teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">\sigma_x^2 = \frac{1}{12}</annotation></semantics></math>. A relação sinal-ruído de quantização, para o quantizador com <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n=2</annotation></semantics></math> bits e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mo>=</mo><mn>1</mn><mi>/</mi><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\Delta = 1/2^n</annotation></semantics></math> = 1/4, será então <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mfrac><mn>1</mn><mn>12</mn></mfrac><mfrac><mrow><mn>1</mn><mi>/</mi><mn>16</mn></mrow><mn>12</mn></mfrac></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mn>16</mn><mo>=</mo><mn>12.0412</mn><mtext mathvariant="normal">dB</mtext><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\frac{1}{12}}{\frac{1/16}{12}} \right) = 10 \log 16 = 12.0412 \text{dB}.
</annotation></semantics></math></p>
<p>Para calcular a SQNR para o sinal senoidal proposto, note que <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><mi>A</mi><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t) = \frac{1}{2} + A \sin(\omega t)</annotation></semantics></math>, onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">A = \frac{1}{2}</annotation></semantics></math>. A constante não muda o resultado e poderemos utilizar a fórmula: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQRN</mtext><mo>=</mo><mn>6</mn><mi>n</mi><mo>+</mo><mn>1.76</mn><mtext mathvariant="normal">dB</mtext><mo>,</mo></mrow><annotation encoding="application/x-tex">
\text{SQRN} = 6n + 1.76 \text{dB} ,
</annotation></semantics></math> onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> é o número de bits do quantizador. Teremos então um <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>13.76</mn><mtext mathvariant="normal">dB</mtext></mrow><annotation encoding="application/x-tex">\text{SQNR} = 13.76 \text{dB}</annotation></semantics></math>. Se calcularmos utilizando <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\Delta = \frac{1}{4}</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">\sigma_x^2 = \frac{1}{8}</annotation></semantics></math>, obteremos o mesmo resultado: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>12</mn><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup></mrow><msup><mi>Δ</mi><mn>2</mn></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mn>24</mn><mtext mathvariant="normal">dB</mtext><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\sigma_x^2}{\sigma_q^2} \right) = 10 \log \left( \frac{12 \sigma_x^2}{\Delta^2} \right) = 10 \log 24 \text{dB}.
</annotation></semantics></math></p>
<ol type = "a">
<li> True. / False. / False. / False. / False </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac><mo>=</mo><mn>0.0052083</mn></mrow><annotation encoding="application/x-tex">D(Q) = \frac{1}{192} = 0.0052083</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mn>16</mn><mo>=</mo><mn>12.0412</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 10 \log 16 = 12.0412</annotation></semantics></math>dB. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mn>24</mn><mo>=</mo><mn>13.80211</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 10 \log 24 = 13.80211</annotation></semantics></math>dB. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>4</defaultgrade>
</question>


<question type="cloze">
<name>
<text> R3 Q1 : scalarquantization_companding01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Suponha que um sinal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math> será amostrado e quantizado através de um quantizador escalar uniforme. O sinal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math> possui extensão <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math>. Um quantizador qualquer pode ser expresso por uma função <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>:</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo>→</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>y</mi><mi>M</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">Q: \mathbb{R} \rightarrow \{y_1, \ldots, y_M\}</annotation></semantics></math>, onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> representa o número de níveis de quantização e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">y_i</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,M</annotation></semantics></math>, os pontos de representação. Considerando um quantizador uniforme com 2 bits, faça o que se pede:</p>
<ol style="list-style-type: lower-alpha">
<li>Determine os pontos de representação <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">y_i</annotation></semantics></math> e os limiares do quantizador, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>i</mi></msub><annotation encoding="application/x-tex">t_i</annotation></semantics></math>;
<ul>
<li>opção a-A = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0.125, 0.375, 0.625, 0.875]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.25, 0.5, 0.75]</code></li>
<li>opção a-B = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[-0.5, 0, 0.5]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[-0.25, 0, 0.25]</code></li>
<li>opção a-C = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0, 0.25, 0.5, 0.75]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.125, 0.375, 0.625]</code></li>
<li>opção a-D = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0.25, 0.5, 0.75, 1]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.375, 0.625, 0.875]</code></li>
</ul></li>
<li><p>Usualmente, para avaliar a performance de um quantizador, utiliza-se o erro médio quadrático (MSE), e para tanto, utilizamos como medida de distorção o quadrado da diferença, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>Q</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mi>Q</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d(x,Q(x)) = (x - Q(x))^2</annotation></semantics></math>. Calcule o valor esperado da distorção <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">D(Q)</annotation></semantics></math> para um sinal de entrada com distribuição uniforme.</p></li>
<li><p>Calcule a relação sinal-ruído de quantização para um sinal de entrada com distribuição uniforme.</p></li>
<li><p>Calcule a relação sinal-ruído de quantização para um sinal de entrada senoidal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(t) = \frac{1}{2}\left( 1 + \sin(\omega t) \right)</annotation></semantics></math>.</p></li>
</ol>
<ol type = "a">
<li> {1:MULTICHOICE:%100%opção a-A~%0%opção a-B~%0%opção a-C~%0%opção a-D~%0%nenhuma das anteriores} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac></mrow><annotation encoding="application/x-tex">D(Q) = \frac{1}{192}</annotation></semantics></math>. {1:NUMERICAL:=0.0052083:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>12.0412</mn></mrow><annotation encoding="application/x-tex">D(Q) = 12.0412</annotation></semantics></math>dB. {1:NUMERICAL:=12.0412:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>13.76</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 13.76</annotation></semantics></math>dB. {1:NUMERICAL:=13.80211:0.01} </li>
</ol>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<p>Como o quantizador é de 2-bits, teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2^2 = 4</annotation></semantics></math> pontos de representação no intervalo <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math>. Iremos dividir o intervalo <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math> em 4 regiões de mesmo tamanho (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.25</mn><annotation encoding="application/x-tex">0.25</annotation></semantics></math>): <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>0.25</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,0.25)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.25</mn><mo>,</mo><mn>0.5</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0.25,0.5)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.5</mn><mo>,</mo><mn>0.75</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0.5,0.75)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.75</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0.75,1]</annotation></semantics></math>. Os limiares então serão: 0.25, 0.5 e 0.75. Os pontos de representação serão colocados no meio de cada intervalo: 0.125, 0.375, 0.625 e 0.875.</p>
<p>Abaixo seguem os cálculos de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">D(Q)</annotation></semantics></math> para um sinal com distribuição uniforme na entrada. Para facilitar, reconhecemos que cada uma das 4 integrais no somatório possuem o mesmo valor. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msubsup><mo>∫</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mi>i</mi></msub></msubsup><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∫</mo><mn>0</mn><mn>0.25</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.125</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.25</mn><mn>0.5</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.375</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.5</mn><mn>0.75</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.625</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.75</mn><mn>1</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.875</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mo>×</mo><mn>4</mn><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∫</mo><mn>0</mn><mn>0.25</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.125</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mn>1</mn><mn>8</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mi>x</mi><mo>−</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mfrac><msup><mi>x</mi><mn>3</mn></msup><mn>3</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mo minsize="3.0" maxsize="3.0" stretchy="false" form="postfix">|</mo><mn>0</mn><mfrac><mn>1</mn><mn>4</mn></mfrac></msubsup></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
D(Q) &amp;= \sum_i \int_{t_{i-1}}^{t_i} f(x) (x - y_i)^2 \mathrm{d}x \\
     &amp;= \frac{1}{4} \left( \int_{0}^{0.25}(x-0.125)^2 dx + \int_{0.25}^{0.5}(x-0.375)^2 dx + \int_{0.5}^{0.75}(x-0.625)^2 dx + \int_{0.75}^{1}(x-0.875)^2 dx \right) \\
     &amp;= \frac{1}{4} \times 4 \times \left( \int_{0}^{0.25}(x-0.125)^2 dx \\
     &amp;= \left(\left(\frac{1}{8}\right)^2 x - \frac{1}{4} x^2 + \frac{x^3}{3} \right) \Bigg\rvert_0^{\frac{1}{4}} \\
     &amp;= \frac{1}{192} .
\end{aligned}
</annotation></semantics></math></p>
<p>A relação sinal-ruído de quantização pode ser obtida utilizando a expressão: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\sigma_x^2}{\sigma_q^2} \right)
</annotation></semantics></math> onde, para o quantizador uniforme temos <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><msup><mi>Δ</mi><mn>2</mn></msup><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">
\sigma_q^2 = \frac{\Delta^2}{12} 
</annotation></semantics></math> e para o sinal de entrada <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∼</mo><mstyle mathvariant="script"><mi>𝒰</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \sim \mathcal{U}(a,b)</annotation></semantics></math> temos <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">
\sigma_x^2 = \frac{(b-a)^2}{12}
</annotation></semantics></math> e assim para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∼</mo><mstyle mathvariant="script"><mi>𝒰</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \sim \mathcal{U}(0,1)</annotation></semantics></math> teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">\sigma_x^2 = \frac{1}{12}</annotation></semantics></math>. A relação sinal-ruído de quantização, para o quantizador com <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n=2</annotation></semantics></math> bits e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mo>=</mo><mn>1</mn><mi>/</mi><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\Delta = 1/2^n</annotation></semantics></math> = 1/4, será então <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mfrac><mn>1</mn><mn>12</mn></mfrac><mfrac><mrow><mn>1</mn><mi>/</mi><mn>16</mn></mrow><mn>12</mn></mfrac></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mn>16</mn><mo>=</mo><mn>12.0412</mn><mtext mathvariant="normal">dB</mtext><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\frac{1}{12}}{\frac{1/16}{12}} \right) = 10 \log 16 = 12.0412 \text{dB}.
</annotation></semantics></math></p>
<p>Para calcular a SQNR para o sinal senoidal proposto, note que <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><mi>A</mi><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t) = \frac{1}{2} + A \sin(\omega t)</annotation></semantics></math>, onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">A = \frac{1}{2}</annotation></semantics></math>. A constante não muda o resultado e poderemos utilizar a fórmula: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQRN</mtext><mo>=</mo><mn>6</mn><mi>n</mi><mo>+</mo><mn>1.76</mn><mtext mathvariant="normal">dB</mtext><mo>,</mo></mrow><annotation encoding="application/x-tex">
\text{SQRN} = 6n + 1.76 \text{dB} ,
</annotation></semantics></math> onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> é o número de bits do quantizador. Teremos então um <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>13.76</mn><mtext mathvariant="normal">dB</mtext></mrow><annotation encoding="application/x-tex">\text{SQNR} = 13.76 \text{dB}</annotation></semantics></math>. Se calcularmos utilizando <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\Delta = \frac{1}{4}</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">\sigma_x^2 = \frac{1}{8}</annotation></semantics></math>, obteremos o mesmo resultado: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>12</mn><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup></mrow><msup><mi>Δ</mi><mn>2</mn></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mn>24</mn><mtext mathvariant="normal">dB</mtext><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\sigma_x^2}{\sigma_q^2} \right) = 10 \log \left( \frac{12 \sigma_x^2}{\Delta^2} \right) = 10 \log 24 \text{dB}.
</annotation></semantics></math></p>
<ol type = "a">
<li> True. / False. / False. / False. / False </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac><mo>=</mo><mn>0.0052083</mn></mrow><annotation encoding="application/x-tex">D(Q) = \frac{1}{192} = 0.0052083</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mn>16</mn><mo>=</mo><mn>12.0412</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 10 \log 16 = 12.0412</annotation></semantics></math>dB. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mn>24</mn><mo>=</mo><mn>13.80211</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 10 \log 24 = 13.80211</annotation></semantics></math>dB. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>4</defaultgrade>
</question>


<question type="cloze">
<name>
<text> R4 Q1 : scalarquantization_companding01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Suponha que um sinal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math> será amostrado e quantizado através de um quantizador escalar uniforme. O sinal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math> possui extensão <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math>. Um quantizador qualquer pode ser expresso por uma função <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>:</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo>→</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>y</mi><mi>M</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">Q: \mathbb{R} \rightarrow \{y_1, \ldots, y_M\}</annotation></semantics></math>, onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> representa o número de níveis de quantização e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">y_i</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,M</annotation></semantics></math>, os pontos de representação. Considerando um quantizador uniforme com 2 bits, faça o que se pede:</p>
<ol style="list-style-type: lower-alpha">
<li>Determine os pontos de representação <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">y_i</annotation></semantics></math> e os limiares do quantizador, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>i</mi></msub><annotation encoding="application/x-tex">t_i</annotation></semantics></math>;
<ul>
<li>opção a-A = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0.125, 0.375, 0.625, 0.875]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.25, 0.5, 0.75]</code></li>
<li>opção a-B = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[-0.5, 0, 0.5]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[-0.25, 0, 0.25]</code></li>
<li>opção a-C = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0, 0.25, 0.5, 0.75]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.125, 0.375, 0.625]</code></li>
<li>opção a-D = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0.25, 0.5, 0.75, 1]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.375, 0.625, 0.875]</code></li>
</ul></li>
<li><p>Usualmente, para avaliar a performance de um quantizador, utiliza-se o erro médio quadrático (MSE), e para tanto, utilizamos como medida de distorção o quadrado da diferença, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>Q</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mi>Q</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d(x,Q(x)) = (x - Q(x))^2</annotation></semantics></math>. Calcule o valor esperado da distorção <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">D(Q)</annotation></semantics></math> para um sinal de entrada com distribuição uniforme.</p></li>
<li><p>Calcule a relação sinal-ruído de quantização para um sinal de entrada com distribuição uniforme.</p></li>
<li><p>Calcule a relação sinal-ruído de quantização para um sinal de entrada senoidal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(t) = \frac{1}{2}\left( 1 + \sin(\omega t) \right)</annotation></semantics></math>.</p></li>
</ol>
<ol type = "a">
<li> {1:MULTICHOICE:%100%opção a-A~%0%opção a-B~%0%opção a-C~%0%opção a-D~%0%nenhuma das anteriores} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac></mrow><annotation encoding="application/x-tex">D(Q) = \frac{1}{192}</annotation></semantics></math>. {1:NUMERICAL:=0.0052083:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>12.0412</mn></mrow><annotation encoding="application/x-tex">D(Q) = 12.0412</annotation></semantics></math>dB. {1:NUMERICAL:=12.0412:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>13.76</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 13.76</annotation></semantics></math>dB. {1:NUMERICAL:=13.80211:0.01} </li>
</ol>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<p>Como o quantizador é de 2-bits, teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2^2 = 4</annotation></semantics></math> pontos de representação no intervalo <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math>. Iremos dividir o intervalo <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math> em 4 regiões de mesmo tamanho (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.25</mn><annotation encoding="application/x-tex">0.25</annotation></semantics></math>): <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>0.25</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,0.25)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.25</mn><mo>,</mo><mn>0.5</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0.25,0.5)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.5</mn><mo>,</mo><mn>0.75</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0.5,0.75)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.75</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0.75,1]</annotation></semantics></math>. Os limiares então serão: 0.25, 0.5 e 0.75. Os pontos de representação serão colocados no meio de cada intervalo: 0.125, 0.375, 0.625 e 0.875.</p>
<p>Abaixo seguem os cálculos de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">D(Q)</annotation></semantics></math> para um sinal com distribuição uniforme na entrada. Para facilitar, reconhecemos que cada uma das 4 integrais no somatório possuem o mesmo valor. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msubsup><mo>∫</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mi>i</mi></msub></msubsup><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∫</mo><mn>0</mn><mn>0.25</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.125</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.25</mn><mn>0.5</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.375</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.5</mn><mn>0.75</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.625</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.75</mn><mn>1</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.875</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mo>×</mo><mn>4</mn><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∫</mo><mn>0</mn><mn>0.25</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.125</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mn>1</mn><mn>8</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mi>x</mi><mo>−</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mfrac><msup><mi>x</mi><mn>3</mn></msup><mn>3</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mo minsize="3.0" maxsize="3.0" stretchy="false" form="postfix">|</mo><mn>0</mn><mfrac><mn>1</mn><mn>4</mn></mfrac></msubsup></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
D(Q) &amp;= \sum_i \int_{t_{i-1}}^{t_i} f(x) (x - y_i)^2 \mathrm{d}x \\
     &amp;= \frac{1}{4} \left( \int_{0}^{0.25}(x-0.125)^2 dx + \int_{0.25}^{0.5}(x-0.375)^2 dx + \int_{0.5}^{0.75}(x-0.625)^2 dx + \int_{0.75}^{1}(x-0.875)^2 dx \right) \\
     &amp;= \frac{1}{4} \times 4 \times \left( \int_{0}^{0.25}(x-0.125)^2 dx \\
     &amp;= \left(\left(\frac{1}{8}\right)^2 x - \frac{1}{4} x^2 + \frac{x^3}{3} \right) \Bigg\rvert_0^{\frac{1}{4}} \\
     &amp;= \frac{1}{192} .
\end{aligned}
</annotation></semantics></math></p>
<p>A relação sinal-ruído de quantização pode ser obtida utilizando a expressão: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\sigma_x^2}{\sigma_q^2} \right)
</annotation></semantics></math> onde, para o quantizador uniforme temos <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><msup><mi>Δ</mi><mn>2</mn></msup><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">
\sigma_q^2 = \frac{\Delta^2}{12} 
</annotation></semantics></math> e para o sinal de entrada <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∼</mo><mstyle mathvariant="script"><mi>𝒰</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \sim \mathcal{U}(a,b)</annotation></semantics></math> temos <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">
\sigma_x^2 = \frac{(b-a)^2}{12}
</annotation></semantics></math> e assim para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∼</mo><mstyle mathvariant="script"><mi>𝒰</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \sim \mathcal{U}(0,1)</annotation></semantics></math> teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">\sigma_x^2 = \frac{1}{12}</annotation></semantics></math>. A relação sinal-ruído de quantização, para o quantizador com <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n=2</annotation></semantics></math> bits e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mo>=</mo><mn>1</mn><mi>/</mi><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\Delta = 1/2^n</annotation></semantics></math> = 1/4, será então <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mfrac><mn>1</mn><mn>12</mn></mfrac><mfrac><mrow><mn>1</mn><mi>/</mi><mn>16</mn></mrow><mn>12</mn></mfrac></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mn>16</mn><mo>=</mo><mn>12.0412</mn><mtext mathvariant="normal">dB</mtext><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\frac{1}{12}}{\frac{1/16}{12}} \right) = 10 \log 16 = 12.0412 \text{dB}.
</annotation></semantics></math></p>
<p>Para calcular a SQNR para o sinal senoidal proposto, note que <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><mi>A</mi><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t) = \frac{1}{2} + A \sin(\omega t)</annotation></semantics></math>, onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">A = \frac{1}{2}</annotation></semantics></math>. A constante não muda o resultado e poderemos utilizar a fórmula: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQRN</mtext><mo>=</mo><mn>6</mn><mi>n</mi><mo>+</mo><mn>1.76</mn><mtext mathvariant="normal">dB</mtext><mo>,</mo></mrow><annotation encoding="application/x-tex">
\text{SQRN} = 6n + 1.76 \text{dB} ,
</annotation></semantics></math> onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> é o número de bits do quantizador. Teremos então um <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>13.76</mn><mtext mathvariant="normal">dB</mtext></mrow><annotation encoding="application/x-tex">\text{SQNR} = 13.76 \text{dB}</annotation></semantics></math>. Se calcularmos utilizando <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\Delta = \frac{1}{4}</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">\sigma_x^2 = \frac{1}{8}</annotation></semantics></math>, obteremos o mesmo resultado: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>12</mn><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup></mrow><msup><mi>Δ</mi><mn>2</mn></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mn>24</mn><mtext mathvariant="normal">dB</mtext><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\sigma_x^2}{\sigma_q^2} \right) = 10 \log \left( \frac{12 \sigma_x^2}{\Delta^2} \right) = 10 \log 24 \text{dB}.
</annotation></semantics></math></p>
<ol type = "a">
<li> True. / False. / False. / False. / False </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac><mo>=</mo><mn>0.0052083</mn></mrow><annotation encoding="application/x-tex">D(Q) = \frac{1}{192} = 0.0052083</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mn>16</mn><mo>=</mo><mn>12.0412</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 10 \log 16 = 12.0412</annotation></semantics></math>dB. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mn>24</mn><mo>=</mo><mn>13.80211</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 10 \log 24 = 13.80211</annotation></semantics></math>dB. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>4</defaultgrade>
</question>


<question type="cloze">
<name>
<text> R5 Q1 : scalarquantization_companding01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Suponha que um sinal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math> será amostrado e quantizado através de um quantizador escalar uniforme. O sinal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t)</annotation></semantics></math> possui extensão <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0, 1]</annotation></semantics></math>. Um quantizador qualquer pode ser expresso por uma função <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>:</mo><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mo>→</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>y</mi><mi>M</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">Q: \mathbb{R} \rightarrow \{y_1, \ldots, y_M\}</annotation></semantics></math>, onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> representa o número de níveis de quantização e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">y_i</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">i=1,\ldots,M</annotation></semantics></math>, os pontos de representação. Considerando um quantizador uniforme com 2 bits, faça o que se pede:</p>
<ol style="list-style-type: lower-alpha">
<li>Determine os pontos de representação <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">y_i</annotation></semantics></math> e os limiares do quantizador, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>i</mi></msub><annotation encoding="application/x-tex">t_i</annotation></semantics></math>;
<ul>
<li>opção a-A = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0.125, 0.375, 0.625, 0.875]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.25, 0.5, 0.75]</code></li>
<li>opção a-B = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[-0.5, 0, 0.5]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[-0.25, 0, 0.25]</code></li>
<li>opção a-C = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0, 0.25, 0.5, 0.75]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.125, 0.375, 0.625]</code></li>
<li>opção a-D = <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">y=</annotation></semantics></math><code>[0.25, 0.5, 0.75, 1]</code> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo></mrow><annotation encoding="application/x-tex">t=</annotation></semantics></math><code>[0.375, 0.625, 0.875]</code></li>
</ul></li>
<li><p>Usualmente, para avaliar a performance de um quantizador, utiliza-se o erro médio quadrático (MSE), e para tanto, utilizamos como medida de distorção o quadrado da diferença, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>Q</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mi>Q</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d(x,Q(x)) = (x - Q(x))^2</annotation></semantics></math>. Calcule o valor esperado da distorção <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">D(Q)</annotation></semantics></math> para um sinal de entrada com distribuição uniforme.</p></li>
<li><p>Calcule a relação sinal-ruído de quantização para um sinal de entrada com distribuição uniforme.</p></li>
<li><p>Calcule a relação sinal-ruído de quantização para um sinal de entrada senoidal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(t) = \frac{1}{2}\left( 1 + \sin(\omega t) \right)</annotation></semantics></math>.</p></li>
</ol>
<ol type = "a">
<li> {1:MULTICHOICE:%100%opção a-A~%0%opção a-B~%0%opção a-C~%0%opção a-D~%0%nenhuma das anteriores} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac></mrow><annotation encoding="application/x-tex">D(Q) = \frac{1}{192}</annotation></semantics></math>. {1:NUMERICAL:=0.0052083:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>12.0412</mn></mrow><annotation encoding="application/x-tex">D(Q) = 12.0412</annotation></semantics></math>dB. {1:NUMERICAL:=12.0412:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>13.76</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 13.76</annotation></semantics></math>dB. {1:NUMERICAL:=13.80211:0.01} </li>
</ol>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<p>Como o quantizador é de 2-bits, teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2^2 = 4</annotation></semantics></math> pontos de representação no intervalo <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math>. Iremos dividir o intervalo <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math> em 4 regiões de mesmo tamanho (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.25</mn><annotation encoding="application/x-tex">0.25</annotation></semantics></math>): <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>0.25</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0,0.25)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.25</mn><mo>,</mo><mn>0.5</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0.25,0.5)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.5</mn><mo>,</mo><mn>0.75</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[0.5,0.75)</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0.75</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0.75,1]</annotation></semantics></math>. Os limiares então serão: 0.25, 0.5 e 0.75. Os pontos de representação serão colocados no meio de cada intervalo: 0.125, 0.375, 0.625 e 0.875.</p>
<p>Abaixo seguem os cálculos de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">D(Q)</annotation></semantics></math> para um sinal com distribuição uniforme na entrada. Para facilitar, reconhecemos que cada uma das 4 integrais no somatório possuem o mesmo valor. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mtd><mtd columnalign="left"><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><msubsup><mo>∫</mo><msub><mi>t</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mi>i</mi></msub></msubsup><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mstyle mathvariant="normal"><mi>d</mi></mstyle><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∫</mo><mn>0</mn><mn>0.25</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.125</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.25</mn><mn>0.5</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.375</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.5</mn><mn>0.75</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.625</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo>+</mo><msubsup><mo>∫</mo><mn>0.75</mn><mn>1</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.875</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><mo>×</mo><mn>4</mn><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∫</mo><mn>0</mn><mn>0.25</mn></msubsup><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>−</mo><mn>0.125</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mi>d</mi><mi>x</mi></mrow></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mn>1</mn><mn>8</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mi>x</mi><mo>−</mo><mfrac><mn>1</mn><mn>4</mn></mfrac><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mfrac><msup><mi>x</mi><mn>3</mn></msup><mn>3</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mo minsize="3.0" maxsize="3.0" stretchy="false" form="postfix">|</mo><mn>0</mn><mfrac><mn>1</mn><mn>4</mn></mfrac></msubsup></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac><mi>.</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
D(Q) &amp;= \sum_i \int_{t_{i-1}}^{t_i} f(x) (x - y_i)^2 \mathrm{d}x \\
     &amp;= \frac{1}{4} \left( \int_{0}^{0.25}(x-0.125)^2 dx + \int_{0.25}^{0.5}(x-0.375)^2 dx + \int_{0.5}^{0.75}(x-0.625)^2 dx + \int_{0.75}^{1}(x-0.875)^2 dx \right) \\
     &amp;= \frac{1}{4} \times 4 \times \left( \int_{0}^{0.25}(x-0.125)^2 dx \\
     &amp;= \left(\left(\frac{1}{8}\right)^2 x - \frac{1}{4} x^2 + \frac{x^3}{3} \right) \Bigg\rvert_0^{\frac{1}{4}} \\
     &amp;= \frac{1}{192} .
\end{aligned}
</annotation></semantics></math></p>
<p>A relação sinal-ruído de quantização pode ser obtida utilizando a expressão: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\sigma_x^2}{\sigma_q^2} \right)
</annotation></semantics></math> onde, para o quantizador uniforme temos <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><msup><mi>Δ</mi><mn>2</mn></msup><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">
\sigma_q^2 = \frac{\Delta^2}{12} 
</annotation></semantics></math> e para o sinal de entrada <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∼</mo><mstyle mathvariant="script"><mi>𝒰</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \sim \mathcal{U}(a,b)</annotation></semantics></math> temos <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>−</mo><mi>a</mi><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup></mrow><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">
\sigma_x^2 = \frac{(b-a)^2}{12}
</annotation></semantics></math> e assim para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∼</mo><mstyle mathvariant="script"><mi>𝒰</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \sim \mathcal{U}(0,1)</annotation></semantics></math> teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">\sigma_x^2 = \frac{1}{12}</annotation></semantics></math>. A relação sinal-ruído de quantização, para o quantizador com <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n=2</annotation></semantics></math> bits e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mo>=</mo><mn>1</mn><mi>/</mi><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\Delta = 1/2^n</annotation></semantics></math> = 1/4, será então <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mfrac><mn>1</mn><mn>12</mn></mfrac><mfrac><mrow><mn>1</mn><mi>/</mi><mn>16</mn></mrow><mn>12</mn></mfrac></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mn>16</mn><mo>=</mo><mn>12.0412</mn><mtext mathvariant="normal">dB</mtext><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\frac{1}{12}}{\frac{1/16}{12}} \right) = 10 \log 16 = 12.0412 \text{dB}.
</annotation></semantics></math></p>
<p>Para calcular a SQNR para o sinal senoidal proposto, note que <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><mi>A</mi><mo>sin</mo><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x(t) = \frac{1}{2} + A \sin(\omega t)</annotation></semantics></math>, onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">A = \frac{1}{2}</annotation></semantics></math>. A constante não muda o resultado e poderemos utilizar a fórmula: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQRN</mtext><mo>=</mo><mn>6</mn><mi>n</mi><mo>+</mo><mn>1.76</mn><mtext mathvariant="normal">dB</mtext><mo>,</mo></mrow><annotation encoding="application/x-tex">
\text{SQRN} = 6n + 1.76 \text{dB} ,
</annotation></semantics></math> onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> é o número de bits do quantizador. Teremos então um <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>13.76</mn><mtext mathvariant="normal">dB</mtext></mrow><annotation encoding="application/x-tex">\text{SQNR} = 13.76 \text{dB}</annotation></semantics></math>. Se calcularmos utilizando <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Δ</mi><mo>=</mo><mfrac><mn>1</mn><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\Delta = \frac{1}{4}</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">\sigma_x^2 = \frac{1}{8}</annotation></semantics></math>, obteremos o mesmo resultado: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup><msubsup><mi>σ</mi><mi>q</mi><mn>2</mn></msubsup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mrow><mn>12</mn><msubsup><mi>σ</mi><mi>x</mi><mn>2</mn></msubsup></mrow><msup><mi>Δ</mi><mn>2</mn></msup></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>10</mn><mo>log</mo><mn>24</mn><mtext mathvariant="normal">dB</mtext><mi>.</mi></mrow><annotation encoding="application/x-tex">
\text{SQNR} = 10 \log \left( \frac{\sigma_x^2}{\sigma_q^2} \right) = 10 \log \left( \frac{12 \sigma_x^2}{\Delta^2} \right) = 10 \log 24 \text{dB}.
</annotation></semantics></math></p>
<ol type = "a">
<li> True. / False. / False. / False. / False </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mfrac><mn>1</mn><mn>192</mn></mfrac><mo>=</mo><mn>0.0052083</mn></mrow><annotation encoding="application/x-tex">D(Q) = \frac{1}{192} = 0.0052083</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mn>16</mn><mo>=</mo><mn>12.0412</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 10 \log 16 = 12.0412</annotation></semantics></math>dB. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SQNR</mtext><mo>=</mo><mn>10</mn><mo>log</mo><mn>24</mn><mo>=</mo><mn>13.80211</mn></mrow><annotation encoding="application/x-tex">\text{SQNR} = 10 \log 24 = 13.80211</annotation></semantics></math>dB. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>4</defaultgrade>
</question>


<question type="category">
<category>
<text>$course$/R-exams/Exercise 2</text>
</category>
</question>


<question type="multichoice">
<name>
<text> R1 Q2 : vectorquantization_vecquantz01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Considere o exemplo visto em aula (notebook) em que tomaremos a cada dois pixels de uma imagem e consideraremos cada par como um vetor em <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>2</mn></msup><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math>. Cada par de pixel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x = (x_1, x_2)</annotation></semantics></math> será representado por um ponto no plano <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>×</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 \times x_2</annotation></semantics></math> onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_1</annotation></semantics></math> é o eixo das abscissas e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>2</mn></msub><annotation encoding="application/x-tex">x_2</annotation></semantics></math> o eixo das ordenadas. Os números associados a cada região representam o índice da saída do quantizador associado a cada uma delas. Os pontos em preto representam pares de pixels da foto da Lena.</p>
<p><br />
<img src="fig-vec-quantz-01.png" /></p>
<p>Podemos afirmar que:</p>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<ol type = "a">
<li> True. </li>
<li> False. </li>
<li> True. </li>
<li> True. </li>
<li> False. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>1</defaultgrade>
<shuffleanswers>false</shuffleanswers>
<single>false</single>
<answernumbering>abc</answernumbering>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
Ambos quantizadores vetoriais utilizam o mesmo número de bits.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-50" format="html">
<text><![CDATA[<p>
O quantizador uniforme possui menor distorção.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
A sequência de pixels <code>[100, 25, 225, 230]</code> terá como saída do quantizador uniforme os índices <code>[4,15]</code>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
A sequência de pixels <code>[100, 25, 225, 230]</code> terá como saída do quantizador não-uniforme os índices <code>[8,15]</code>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-50" format="html">
<text><![CDATA[<p>
Podemos afirmar que o quantizador não-uniforme, obtido pelo algoritmo de Lloyds, e apresentado na figura, é o quantizador ótimo (com menor distorção).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
</question>


<question type="multichoice">
<name>
<text> R2 Q2 : vectorquantization_vecquantz01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Considere o exemplo visto em aula (notebook) em que tomaremos a cada dois pixels de uma imagem e consideraremos cada par como um vetor em <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>2</mn></msup><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math>. Cada par de pixel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x = (x_1, x_2)</annotation></semantics></math> será representado por um ponto no plano <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>×</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 \times x_2</annotation></semantics></math> onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_1</annotation></semantics></math> é o eixo das abscissas e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>2</mn></msub><annotation encoding="application/x-tex">x_2</annotation></semantics></math> o eixo das ordenadas. Os números associados a cada região representam o índice da saída do quantizador associado a cada uma delas. Os pontos em preto representam pares de pixels da foto da Lena.</p>
<p><br />
<img src="fig-vec-quantz-01.png" /></p>
<p>Podemos afirmar que:</p>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<ol type = "a">
<li> True. </li>
<li> False. </li>
<li> True. </li>
<li> True. </li>
<li> False. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>1</defaultgrade>
<shuffleanswers>false</shuffleanswers>
<single>false</single>
<answernumbering>abc</answernumbering>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
Ambos quantizadores vetoriais utilizam o mesmo número de bits.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-50" format="html">
<text><![CDATA[<p>
O quantizador uniforme possui menor distorção.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
A sequência de pixels <code>[100, 25, 225, 230]</code> terá como saída do quantizador uniforme os índices <code>[4,15]</code>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
A sequência de pixels <code>[100, 25, 225, 230]</code> terá como saída do quantizador não-uniforme os índices <code>[8,15]</code>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-50" format="html">
<text><![CDATA[<p>
Podemos afirmar que o quantizador não-uniforme, obtido pelo algoritmo de Lloyds, e apresentado na figura, é o quantizador ótimo (com menor distorção).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
</question>


<question type="multichoice">
<name>
<text> R3 Q2 : vectorquantization_vecquantz01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Considere o exemplo visto em aula (notebook) em que tomaremos a cada dois pixels de uma imagem e consideraremos cada par como um vetor em <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>2</mn></msup><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math>. Cada par de pixel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x = (x_1, x_2)</annotation></semantics></math> será representado por um ponto no plano <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>×</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 \times x_2</annotation></semantics></math> onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_1</annotation></semantics></math> é o eixo das abscissas e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>2</mn></msub><annotation encoding="application/x-tex">x_2</annotation></semantics></math> o eixo das ordenadas. Os números associados a cada região representam o índice da saída do quantizador associado a cada uma delas. Os pontos em preto representam pares de pixels da foto da Lena.</p>
<p><br />
<img src="fig-vec-quantz-01.png" /></p>
<p>Podemos afirmar que:</p>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<ol type = "a">
<li> True. </li>
<li> False. </li>
<li> True. </li>
<li> True. </li>
<li> False. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>1</defaultgrade>
<shuffleanswers>false</shuffleanswers>
<single>false</single>
<answernumbering>abc</answernumbering>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
Ambos quantizadores vetoriais utilizam o mesmo número de bits.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-50" format="html">
<text><![CDATA[<p>
O quantizador uniforme possui menor distorção.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
A sequência de pixels <code>[100, 25, 225, 230]</code> terá como saída do quantizador uniforme os índices <code>[4,15]</code>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
A sequência de pixels <code>[100, 25, 225, 230]</code> terá como saída do quantizador não-uniforme os índices <code>[8,15]</code>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-50" format="html">
<text><![CDATA[<p>
Podemos afirmar que o quantizador não-uniforme, obtido pelo algoritmo de Lloyds, e apresentado na figura, é o quantizador ótimo (com menor distorção).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
</question>


<question type="multichoice">
<name>
<text> R4 Q2 : vectorquantization_vecquantz01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Considere o exemplo visto em aula (notebook) em que tomaremos a cada dois pixels de uma imagem e consideraremos cada par como um vetor em <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>2</mn></msup><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math>. Cada par de pixel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x = (x_1, x_2)</annotation></semantics></math> será representado por um ponto no plano <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>×</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 \times x_2</annotation></semantics></math> onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_1</annotation></semantics></math> é o eixo das abscissas e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>2</mn></msub><annotation encoding="application/x-tex">x_2</annotation></semantics></math> o eixo das ordenadas. Os números associados a cada região representam o índice da saída do quantizador associado a cada uma delas. Os pontos em preto representam pares de pixels da foto da Lena.</p>
<p><br />
<img src="fig-vec-quantz-01.png" /></p>
<p>Podemos afirmar que:</p>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<ol type = "a">
<li> True. </li>
<li> False. </li>
<li> True. </li>
<li> True. </li>
<li> False. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>1</defaultgrade>
<shuffleanswers>false</shuffleanswers>
<single>false</single>
<answernumbering>abc</answernumbering>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
Ambos quantizadores vetoriais utilizam o mesmo número de bits.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-50" format="html">
<text><![CDATA[<p>
O quantizador uniforme possui menor distorção.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
A sequência de pixels <code>[100, 25, 225, 230]</code> terá como saída do quantizador uniforme os índices <code>[4,15]</code>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
A sequência de pixels <code>[100, 25, 225, 230]</code> terá como saída do quantizador não-uniforme os índices <code>[8,15]</code>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-50" format="html">
<text><![CDATA[<p>
Podemos afirmar que o quantizador não-uniforme, obtido pelo algoritmo de Lloyds, e apresentado na figura, é o quantizador ótimo (com menor distorção).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
</question>


<question type="multichoice">
<name>
<text> R5 Q2 : vectorquantization_vecquantz01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Considere o exemplo visto em aula (notebook) em que tomaremos a cada dois pixels de uma imagem e consideraremos cada par como um vetor em <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mstyle mathvariant="double-struck"><mi>ℝ</mi></mstyle><mn>2</mn></msup><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math>. Cada par de pixel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x = (x_1, x_2)</annotation></semantics></math> será representado por um ponto no plano <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>×</mo><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 \times x_2</annotation></semantics></math> onde <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>1</mn></msub><annotation encoding="application/x-tex">x_1</annotation></semantics></math> é o eixo das abscissas e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mn>2</mn></msub><annotation encoding="application/x-tex">x_2</annotation></semantics></math> o eixo das ordenadas. Os números associados a cada região representam o índice da saída do quantizador associado a cada uma delas. Os pontos em preto representam pares de pixels da foto da Lena.</p>
<p><br />
<img src="fig-vec-quantz-01.png" /></p>
<p>Podemos afirmar que:</p>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<ol type = "a">
<li> True. </li>
<li> False. </li>
<li> True. </li>
<li> True. </li>
<li> False. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>1</defaultgrade>
<shuffleanswers>false</shuffleanswers>
<single>false</single>
<answernumbering>abc</answernumbering>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
Ambos quantizadores vetoriais utilizam o mesmo número de bits.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-50" format="html">
<text><![CDATA[<p>
O quantizador uniforme possui menor distorção.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
A sequência de pixels <code>[100, 25, 225, 230]</code> terá como saída do quantizador uniforme os índices <code>[4,15]</code>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="33.33333" format="html">
<text><![CDATA[<p>
A sequência de pixels <code>[100, 25, 225, 230]</code> terá como saída do quantizador não-uniforme os índices <code>[8,15]</code>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-50" format="html">
<text><![CDATA[<p>
Podemos afirmar que o quantizador não-uniforme, obtido pelo algoritmo de Lloyds, e apresentado na figura, é o quantizador ótimo (com menor distorção).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
</question>


<question type="category">
<category>
<text>$course$/R-exams/Exercise 3</text>
</category>
</question>


<question type="multichoice">
<name>
<text> R1 Q3 : vectorquantization_vecquantz02 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>A figura abaixo ilustra o processo de quantização de cores de uma imagem. À esquerda temos a imagem original, no meio uma palheta de cores e à direita a imagem resultante da quantização de cores.</p>
<p><br />
<img src="colorquantization.png" /></p>
<p>Com relação a este processo de quantização, podemos afirmar que:</p>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<ol type = "a">
<li> True. </li>
<li> False. </li>
<li> False. </li>
<li> True. </li>
<li> False. </li>
<li> False. </li>
<li> True. </li>
<li> False. </li>
<li> True. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>1</defaultgrade>
<shuffleanswers>false</shuffleanswers>
<single>false</single>
<answernumbering>abc</answernumbering>
<answer fraction="25" format="html">
<text><![CDATA[<p>
É possível reduzir o número de bits necessários para representar uma imagem utilizando uma quantização de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A quantização de cores é uma quantização escalar.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores é única, ou seja, só existe uma forma de se obter/criar uma palheta de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O dithering pode ser utilizado conjuntamente com a quantização para obtermos uma imagem com menos regiões de cores chapadas, criando a sensação de uma imagem mais realista.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores deve ter menos do que 256 cores para ser possível obter uma taxa de compressão maior do que 1 (um).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores deve ter mais do que 256 cores para criar uma representação natural de imagens reais (fotos).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O algoritmo de corte de mediana é utilizado para criar uma palheta de cores com tamanho <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A melhor forma (menor distorção e maior taxa de compressão) de se obter uma palheta de cores é dividir uniformemente o espaço de cores, atribuindo o mesmo número de bits para as componentes R, G e B.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O dithering pode ser utilizado na quantização cores conjuntamente com qualquer método para obter a palheta de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
</question>


<question type="multichoice">
<name>
<text> R2 Q3 : vectorquantization_vecquantz02 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>A figura abaixo ilustra o processo de quantização de cores de uma imagem. À esquerda temos a imagem original, no meio uma palheta de cores e à direita a imagem resultante da quantização de cores.</p>
<p><br />
<img src="colorquantization.png" /></p>
<p>Com relação a este processo de quantização, podemos afirmar que:</p>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<ol type = "a">
<li> True. </li>
<li> False. </li>
<li> False. </li>
<li> True. </li>
<li> False. </li>
<li> False. </li>
<li> True. </li>
<li> False. </li>
<li> True. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>1</defaultgrade>
<shuffleanswers>false</shuffleanswers>
<single>false</single>
<answernumbering>abc</answernumbering>
<answer fraction="25" format="html">
<text><![CDATA[<p>
É possível reduzir o número de bits necessários para representar uma imagem utilizando uma quantização de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A quantização de cores é uma quantização escalar.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores é única, ou seja, só existe uma forma de se obter/criar uma palheta de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O dithering pode ser utilizado conjuntamente com a quantização para obtermos uma imagem com menos regiões de cores chapadas, criando a sensação de uma imagem mais realista.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores deve ter menos do que 256 cores para ser possível obter uma taxa de compressão maior do que 1 (um).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores deve ter mais do que 256 cores para criar uma representação natural de imagens reais (fotos).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O algoritmo de corte de mediana é utilizado para criar uma palheta de cores com tamanho <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A melhor forma (menor distorção e maior taxa de compressão) de se obter uma palheta de cores é dividir uniformemente o espaço de cores, atribuindo o mesmo número de bits para as componentes R, G e B.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O dithering pode ser utilizado na quantização cores conjuntamente com qualquer método para obter a palheta de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
</question>


<question type="multichoice">
<name>
<text> R3 Q3 : vectorquantization_vecquantz02 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>A figura abaixo ilustra o processo de quantização de cores de uma imagem. À esquerda temos a imagem original, no meio uma palheta de cores e à direita a imagem resultante da quantização de cores.</p>
<p><br />
<img src="colorquantization.png" /></p>
<p>Com relação a este processo de quantização, podemos afirmar que:</p>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<ol type = "a">
<li> True. </li>
<li> False. </li>
<li> False. </li>
<li> True. </li>
<li> False. </li>
<li> False. </li>
<li> True. </li>
<li> False. </li>
<li> True. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>1</defaultgrade>
<shuffleanswers>false</shuffleanswers>
<single>false</single>
<answernumbering>abc</answernumbering>
<answer fraction="25" format="html">
<text><![CDATA[<p>
É possível reduzir o número de bits necessários para representar uma imagem utilizando uma quantização de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A quantização de cores é uma quantização escalar.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores é única, ou seja, só existe uma forma de se obter/criar uma palheta de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O dithering pode ser utilizado conjuntamente com a quantização para obtermos uma imagem com menos regiões de cores chapadas, criando a sensação de uma imagem mais realista.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores deve ter menos do que 256 cores para ser possível obter uma taxa de compressão maior do que 1 (um).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores deve ter mais do que 256 cores para criar uma representação natural de imagens reais (fotos).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O algoritmo de corte de mediana é utilizado para criar uma palheta de cores com tamanho <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A melhor forma (menor distorção e maior taxa de compressão) de se obter uma palheta de cores é dividir uniformemente o espaço de cores, atribuindo o mesmo número de bits para as componentes R, G e B.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O dithering pode ser utilizado na quantização cores conjuntamente com qualquer método para obter a palheta de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
</question>


<question type="multichoice">
<name>
<text> R4 Q3 : vectorquantization_vecquantz02 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>A figura abaixo ilustra o processo de quantização de cores de uma imagem. À esquerda temos a imagem original, no meio uma palheta de cores e à direita a imagem resultante da quantização de cores.</p>
<p><br />
<img src="colorquantization.png" /></p>
<p>Com relação a este processo de quantização, podemos afirmar que:</p>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<ol type = "a">
<li> True. </li>
<li> False. </li>
<li> False. </li>
<li> True. </li>
<li> False. </li>
<li> False. </li>
<li> True. </li>
<li> False. </li>
<li> True. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>1</defaultgrade>
<shuffleanswers>false</shuffleanswers>
<single>false</single>
<answernumbering>abc</answernumbering>
<answer fraction="25" format="html">
<text><![CDATA[<p>
É possível reduzir o número de bits necessários para representar uma imagem utilizando uma quantização de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A quantização de cores é uma quantização escalar.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores é única, ou seja, só existe uma forma de se obter/criar uma palheta de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O dithering pode ser utilizado conjuntamente com a quantização para obtermos uma imagem com menos regiões de cores chapadas, criando a sensação de uma imagem mais realista.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores deve ter menos do que 256 cores para ser possível obter uma taxa de compressão maior do que 1 (um).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores deve ter mais do que 256 cores para criar uma representação natural de imagens reais (fotos).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O algoritmo de corte de mediana é utilizado para criar uma palheta de cores com tamanho <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A melhor forma (menor distorção e maior taxa de compressão) de se obter uma palheta de cores é dividir uniformemente o espaço de cores, atribuindo o mesmo número de bits para as componentes R, G e B.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O dithering pode ser utilizado na quantização cores conjuntamente com qualquer método para obter a palheta de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
</question>


<question type="multichoice">
<name>
<text> R5 Q3 : vectorquantization_vecquantz02 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>A figura abaixo ilustra o processo de quantização de cores de uma imagem. À esquerda temos a imagem original, no meio uma palheta de cores e à direita a imagem resultante da quantização de cores.</p>
<p><br />
<img src="colorquantization.png" /></p>
<p>Com relação a este processo de quantização, podemos afirmar que:</p>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<ol type = "a">
<li> True. </li>
<li> False. </li>
<li> False. </li>
<li> True. </li>
<li> False. </li>
<li> False. </li>
<li> True. </li>
<li> False. </li>
<li> True. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>1</defaultgrade>
<shuffleanswers>false</shuffleanswers>
<single>false</single>
<answernumbering>abc</answernumbering>
<answer fraction="25" format="html">
<text><![CDATA[<p>
É possível reduzir o número de bits necessários para representar uma imagem utilizando uma quantização de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A quantização de cores é uma quantização escalar.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores é única, ou seja, só existe uma forma de se obter/criar uma palheta de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O dithering pode ser utilizado conjuntamente com a quantização para obtermos uma imagem com menos regiões de cores chapadas, criando a sensação de uma imagem mais realista.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores deve ter menos do que 256 cores para ser possível obter uma taxa de compressão maior do que 1 (um).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A palheta de cores deve ter mais do que 256 cores para criar uma representação natural de imagens reais (fotos).
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O algoritmo de corte de mediana é utilizado para criar uma palheta de cores com tamanho <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mi>n</mi></msup><annotation encoding="application/x-tex">2^n</annotation></semantics></math>.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
<answer fraction="-20" format="html">
<text><![CDATA[<p>
A melhor forma (menor distorção e maior taxa de compressão) de se obter uma palheta de cores é dividir uniformemente o espaço de cores, atribuindo o mesmo número de bits para as componentes R, G e B.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
False.
</p>]]></text>
</feedback>
</answer>
<answer fraction="25" format="html">
<text><![CDATA[<p>
O dithering pode ser utilizado na quantização cores conjuntamente com qualquer método para obter a palheta de cores.
</p>]]></text>
<feedback format="html">
<text><![CDATA[<p>
True.
</p>]]></text>
</feedback>
</answer>
</question>


<question type="category">
<category>
<text>$course$/R-exams/Exercise 4</text>
</category>
</question>


<question type="cloze">
<name>
<text> R1 Q4 : sampling_downsample01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Considere o sistema de reamostragem apresentado na Figura abaixo.</p>
<p><br />
<img src="fig429.png" /></p>
<p>Seja <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x[n]</annotation></semantics></math> o sinal de entrada, com transformada de Fourier dada por <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">X(e^{j\omega})</annotation></semantics></math> apresentado na Figura a seguir:</p>
<p><br />
<img src="fig418.png" /></p>
<p>Para cada uma dos valores de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>, especifique (em radianos) qual é o maior valor possível para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math> de forma que <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̃</mo></mover><mi>d</mi></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>M</mi><mi>ω</mi><mi>/</mi><mi>L</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\tilde{X}_d(e^{j\omega}) = aX(e^{j M \omega /L})</annotation></semantics></math> para alguma constante <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>.</p>
<ol type = "a">
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math> {1:NUMERICAL:=2.094395:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">M=5</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math> {1:NUMERICAL:=1.884956:0.01} </li>
</ol>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<p>Para que a condição <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̃</mo></mover><mi>d</mi></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>M</mi><mi>ω</mi><mi>/</mi><mi>L</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\tilde{X}_d(e^{j\omega}) = aX(e^{j M \omega /L})</annotation></semantics></math> seja satisfeita, não deve ocorrer nenhuma perda de informação na reamostragem. Para que isto ocorra, devemos escolher <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math> para que a frequência máxima de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>e</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x_e[n]</annotation></semantics></math> seja menor do que do que a frequência de corte do filtro passa-baixas: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mi>/</mi><mi>L</mi><mo>≤</mo><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mi>/</mi><mi>L</mi><mo>,</mo><mi>π</mi><mi>/</mi><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\omega_0/L \leq \min(\pi/L,\pi/M)</annotation></semantics></math>. Com esta escolha, o filtro passa-baixas não cortará nenhuma parte do espectro.</p>
<ol style="list-style-type: lower-alpha">
<li>Para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math>, teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mi>/</mi><mn>2</mn><mo>≤</mo><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mi>/</mi><mn>2</mn><mo>,</mo><mi>π</mi><mi>/</mi><mn>3</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\omega_0/2 \leq \min(\pi/2, \pi/3)</annotation></semantics></math>, e assim <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mn>2</mn><mi>π</mi><mi>/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\omega_0 \leq 2 \pi/3</annotation></semantics></math>.</li>
<li>Para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mn>3</mn><mi>π</mi><mi>/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">\omega_0 \leq 3 \pi/5</annotation></semantics></math>.</li>
<li>Com <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>&gt;</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">L &gt; M</annotation></semantics></math>, não ocorrerá aliasing. Assim não é necessário impor limite sobre <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math>, ou seja, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\omega_0 \leq \pi</annotation></semantics></math>.</li>
</ol>
<ol type = "a">
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mn>2</mn><mi>π</mi><mi>/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\omega_0 = 2\pi/3</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mn>3</mn><mi>π</mi><mi>/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">\omega_0 = 3\pi/5</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\omega_0 = \pi</annotation></semantics></math>. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>3</defaultgrade>
</question>


<question type="cloze">
<name>
<text> R2 Q4 : sampling_downsample01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Considere o sistema de reamostragem apresentado na Figura abaixo.</p>
<p><br />
<img src="fig429.png" /></p>
<p>Seja <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x[n]</annotation></semantics></math> o sinal de entrada, com transformada de Fourier dada por <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">X(e^{j\omega})</annotation></semantics></math> apresentado na Figura a seguir:</p>
<p><br />
<img src="fig418.png" /></p>
<p>Para cada uma dos valores de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>, especifique (em radianos) qual é o maior valor possível para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math> de forma que <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̃</mo></mover><mi>d</mi></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>M</mi><mi>ω</mi><mi>/</mi><mi>L</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\tilde{X}_d(e^{j\omega}) = aX(e^{j M \omega /L})</annotation></semantics></math> para alguma constante <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>.</p>
<ol type = "a">
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math> {1:NUMERICAL:=2.094395:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">M=5</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math> {1:NUMERICAL:=1.884956:0.01} </li>
</ol>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<p>Para que a condição <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̃</mo></mover><mi>d</mi></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>M</mi><mi>ω</mi><mi>/</mi><mi>L</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\tilde{X}_d(e^{j\omega}) = aX(e^{j M \omega /L})</annotation></semantics></math> seja satisfeita, não deve ocorrer nenhuma perda de informação na reamostragem. Para que isto ocorra, devemos escolher <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math> para que a frequência máxima de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>e</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x_e[n]</annotation></semantics></math> seja menor do que do que a frequência de corte do filtro passa-baixas: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mi>/</mi><mi>L</mi><mo>≤</mo><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mi>/</mi><mi>L</mi><mo>,</mo><mi>π</mi><mi>/</mi><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\omega_0/L \leq \min(\pi/L,\pi/M)</annotation></semantics></math>. Com esta escolha, o filtro passa-baixas não cortará nenhuma parte do espectro.</p>
<ol style="list-style-type: lower-alpha">
<li>Para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math>, teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mi>/</mi><mn>2</mn><mo>≤</mo><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mi>/</mi><mn>2</mn><mo>,</mo><mi>π</mi><mi>/</mi><mn>3</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\omega_0/2 \leq \min(\pi/2, \pi/3)</annotation></semantics></math>, e assim <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mn>2</mn><mi>π</mi><mi>/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\omega_0 \leq 2 \pi/3</annotation></semantics></math>.</li>
<li>Para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mn>3</mn><mi>π</mi><mi>/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">\omega_0 \leq 3 \pi/5</annotation></semantics></math>.</li>
<li>Com <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>&gt;</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">L &gt; M</annotation></semantics></math>, não ocorrerá aliasing. Assim não é necessário impor limite sobre <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math>, ou seja, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\omega_0 \leq \pi</annotation></semantics></math>.</li>
</ol>
<ol type = "a">
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mn>2</mn><mi>π</mi><mi>/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\omega_0 = 2\pi/3</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mn>3</mn><mi>π</mi><mi>/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">\omega_0 = 3\pi/5</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\omega_0 = \pi</annotation></semantics></math>. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>3</defaultgrade>
</question>


<question type="cloze">
<name>
<text> R3 Q4 : sampling_downsample01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Considere o sistema de reamostragem apresentado na Figura abaixo.</p>
<p><br />
<img src="fig429.png" /></p>
<p>Seja <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x[n]</annotation></semantics></math> o sinal de entrada, com transformada de Fourier dada por <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">X(e^{j\omega})</annotation></semantics></math> apresentado na Figura a seguir:</p>
<p><br />
<img src="fig418.png" /></p>
<p>Para cada uma dos valores de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>, especifique (em radianos) qual é o maior valor possível para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math> de forma que <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̃</mo></mover><mi>d</mi></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>M</mi><mi>ω</mi><mi>/</mi><mi>L</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\tilde{X}_d(e^{j\omega}) = aX(e^{j M \omega /L})</annotation></semantics></math> para alguma constante <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>.</p>
<ol type = "a">
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math> {1:NUMERICAL:=2.094395:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">M=5</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math> {1:NUMERICAL:=1.884956:0.01} </li>
</ol>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<p>Para que a condição <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̃</mo></mover><mi>d</mi></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>M</mi><mi>ω</mi><mi>/</mi><mi>L</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\tilde{X}_d(e^{j\omega}) = aX(e^{j M \omega /L})</annotation></semantics></math> seja satisfeita, não deve ocorrer nenhuma perda de informação na reamostragem. Para que isto ocorra, devemos escolher <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math> para que a frequência máxima de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>e</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x_e[n]</annotation></semantics></math> seja menor do que do que a frequência de corte do filtro passa-baixas: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mi>/</mi><mi>L</mi><mo>≤</mo><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mi>/</mi><mi>L</mi><mo>,</mo><mi>π</mi><mi>/</mi><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\omega_0/L \leq \min(\pi/L,\pi/M)</annotation></semantics></math>. Com esta escolha, o filtro passa-baixas não cortará nenhuma parte do espectro.</p>
<ol style="list-style-type: lower-alpha">
<li>Para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math>, teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mi>/</mi><mn>2</mn><mo>≤</mo><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mi>/</mi><mn>2</mn><mo>,</mo><mi>π</mi><mi>/</mi><mn>3</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\omega_0/2 \leq \min(\pi/2, \pi/3)</annotation></semantics></math>, e assim <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mn>2</mn><mi>π</mi><mi>/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\omega_0 \leq 2 \pi/3</annotation></semantics></math>.</li>
<li>Para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mn>3</mn><mi>π</mi><mi>/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">\omega_0 \leq 3 \pi/5</annotation></semantics></math>.</li>
<li>Com <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>&gt;</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">L &gt; M</annotation></semantics></math>, não ocorrerá aliasing. Assim não é necessário impor limite sobre <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math>, ou seja, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\omega_0 \leq \pi</annotation></semantics></math>.</li>
</ol>
<ol type = "a">
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mn>2</mn><mi>π</mi><mi>/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\omega_0 = 2\pi/3</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mn>3</mn><mi>π</mi><mi>/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">\omega_0 = 3\pi/5</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\omega_0 = \pi</annotation></semantics></math>. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>3</defaultgrade>
</question>


<question type="cloze">
<name>
<text> R4 Q4 : sampling_downsample01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Considere o sistema de reamostragem apresentado na Figura abaixo.</p>
<p><br />
<img src="fig429.png" /></p>
<p>Seja <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x[n]</annotation></semantics></math> o sinal de entrada, com transformada de Fourier dada por <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">X(e^{j\omega})</annotation></semantics></math> apresentado na Figura a seguir:</p>
<p><br />
<img src="fig418.png" /></p>
<p>Para cada uma dos valores de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>, especifique (em radianos) qual é o maior valor possível para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math> de forma que <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̃</mo></mover><mi>d</mi></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>M</mi><mi>ω</mi><mi>/</mi><mi>L</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\tilde{X}_d(e^{j\omega}) = aX(e^{j M \omega /L})</annotation></semantics></math> para alguma constante <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>.</p>
<ol type = "a">
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math> {1:NUMERICAL:=2.094395:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">M=5</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math> {1:NUMERICAL:=1.884956:0.01} </li>
</ol>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<p>Para que a condição <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̃</mo></mover><mi>d</mi></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>M</mi><mi>ω</mi><mi>/</mi><mi>L</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\tilde{X}_d(e^{j\omega}) = aX(e^{j M \omega /L})</annotation></semantics></math> seja satisfeita, não deve ocorrer nenhuma perda de informação na reamostragem. Para que isto ocorra, devemos escolher <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math> para que a frequência máxima de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>e</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x_e[n]</annotation></semantics></math> seja menor do que do que a frequência de corte do filtro passa-baixas: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mi>/</mi><mi>L</mi><mo>≤</mo><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mi>/</mi><mi>L</mi><mo>,</mo><mi>π</mi><mi>/</mi><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\omega_0/L \leq \min(\pi/L,\pi/M)</annotation></semantics></math>. Com esta escolha, o filtro passa-baixas não cortará nenhuma parte do espectro.</p>
<ol style="list-style-type: lower-alpha">
<li>Para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math>, teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mi>/</mi><mn>2</mn><mo>≤</mo><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mi>/</mi><mn>2</mn><mo>,</mo><mi>π</mi><mi>/</mi><mn>3</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\omega_0/2 \leq \min(\pi/2, \pi/3)</annotation></semantics></math>, e assim <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mn>2</mn><mi>π</mi><mi>/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\omega_0 \leq 2 \pi/3</annotation></semantics></math>.</li>
<li>Para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mn>3</mn><mi>π</mi><mi>/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">\omega_0 \leq 3 \pi/5</annotation></semantics></math>.</li>
<li>Com <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>&gt;</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">L &gt; M</annotation></semantics></math>, não ocorrerá aliasing. Assim não é necessário impor limite sobre <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math>, ou seja, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\omega_0 \leq \pi</annotation></semantics></math>.</li>
</ol>
<ol type = "a">
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mn>2</mn><mi>π</mi><mi>/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\omega_0 = 2\pi/3</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mn>3</mn><mi>π</mi><mi>/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">\omega_0 = 3\pi/5</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\omega_0 = \pi</annotation></semantics></math>. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>3</defaultgrade>
</question>


<question type="cloze">
<name>
<text> R5 Q4 : sampling_downsample01 </text>
</name>
<questiontext format="html">
<text><![CDATA[<p>
<p>Considere o sistema de reamostragem apresentado na Figura abaixo.</p>
<p><br />
<img src="fig429.png" /></p>
<p>Seja <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x[n]</annotation></semantics></math> o sinal de entrada, com transformada de Fourier dada por <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">X(e^{j\omega})</annotation></semantics></math> apresentado na Figura a seguir:</p>
<p><br />
<img src="fig418.png" /></p>
<p>Para cada uma dos valores de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>, especifique (em radianos) qual é o maior valor possível para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math> de forma que <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̃</mo></mover><mi>d</mi></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>M</mi><mi>ω</mi><mi>/</mi><mi>L</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\tilde{X}_d(e^{j\omega}) = aX(e^{j M \omega /L})</annotation></semantics></math> para alguma constante <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>.</p>
<ol type = "a">
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math> {1:NUMERICAL:=2.094395:0.01} </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">M=5</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math> {1:NUMERICAL:=1.884956:0.01} </li>
</ol>
</p>]]></text>
</questiontext>
<generalfeedback format="html">
<text><![CDATA[<p>
<p>Para que a condição <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>X</mi><mo accent="true">̃</mo></mover><mi>d</mi></msub><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>ω</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mi>X</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>j</mi><mi>M</mi><mi>ω</mi><mi>/</mi><mi>L</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\tilde{X}_d(e^{j\omega}) = aX(e^{j M \omega /L})</annotation></semantics></math> seja satisfeita, não deve ocorrer nenhuma perda de informação na reamostragem. Para que isto ocorra, devemos escolher <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math> para que a frequência máxima de <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>e</mi></msub><mo stretchy="false" form="prefix">[</mo><mi>n</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x_e[n]</annotation></semantics></math> seja menor do que do que a frequência de corte do filtro passa-baixas: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mi>/</mi><mi>L</mi><mo>≤</mo><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mi>/</mi><mi>L</mi><mo>,</mo><mi>π</mi><mi>/</mi><mi>M</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\omega_0/L \leq \min(\pi/L,\pi/M)</annotation></semantics></math>. Com esta escolha, o filtro passa-baixas não cortará nenhuma parte do espectro.</p>
<ol style="list-style-type: lower-alpha">
<li>Para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math>, teremos <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mi>/</mi><mn>2</mn><mo>≤</mo><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mi>/</mi><mn>2</mn><mo>,</mo><mi>π</mi><mi>/</mi><mn>3</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\omega_0/2 \leq \min(\pi/2, \pi/3)</annotation></semantics></math>, e assim <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mn>2</mn><mi>π</mi><mi>/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\omega_0 \leq 2 \pi/3</annotation></semantics></math>.</li>
<li>Para <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">M=3</annotation></semantics></math> e <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">L=2</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mn>3</mn><mi>π</mi><mi>/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">\omega_0 \leq 3 \pi/5</annotation></semantics></math>.</li>
<li>Com <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>&gt;</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">L &gt; M</annotation></semantics></math>, não ocorrerá aliasing. Assim não é necessário impor limite sobre <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ω</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\omega_0</annotation></semantics></math>, ou seja, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>≤</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\omega_0 \leq \pi</annotation></semantics></math>.</li>
</ol>
<ol type = "a">
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mn>2</mn><mi>π</mi><mi>/</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\omega_0 = 2\pi/3</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mn>3</mn><mi>π</mi><mi>/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">\omega_0 = 3\pi/5</annotation></semantics></math>. </li>
<li> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ω</mi><mn>0</mn></msub><mo>=</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">\omega_0 = \pi</annotation></semantics></math>. </li>
</ol>
</p>]]></text>
</generalfeedback>
<penalty>0</penalty>
<defaultgrade>3</defaultgrade>
</question>

</quiz>
